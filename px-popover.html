
<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
    See https://github.com/jreichenberg/grunt-dep-serve#why-do-we-need-this
-->
<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">


<!--
Element providing popovers.

Simply place the the px-popover next to the element that you want it to attach to.
Set the 'for' attribute to the 'id' of the element that it's associated with. Then Set
the 'popover-title' and 'popover-body' attributes. The popover will automatically grow
to encapsulate the contents that you have established. The 'interaction' attribute specifies
the event that the popover is bound to, currently the popover supports 'click', 'focus' and ‘hover’.

NOTE: currently the popover must be a sibling of the associated element, both should
contained within a 'static' element such as a DIV. Relative or aboslute positioned parent
elements are not supported.

##### Usage

    <div class="static-parent">
        <div id="someElement">Some element</div>
        <px-popover for="someElement" interaction="click" orientation="bottom" popover-title="Bottom Popover" popover-body="Lorem ipsum dolor sit amet, consectetur elit, sed do eiusmod."></px-popover>
    </div>

@element px-popover
@blurb Element providing popover interactions to the applicaiton developers.
@homepage index.html
@demo demo.html
-->
<dom-module id="px-popover">
    <link rel="import" type="css" href="css/px-popover.css"/>
    <template>
        <div id="popoverWrapper" class="hidden">
            <div id="carat"></div>
            <div id="popover">
                <p>{{popoverTitle}}</p>
                <p>{{popoverBody}}</p>
            </div>
        </div>
    </template>
</dom-module>

<script>
    Polymer({

        is: 'px-popover',
        behaviors: [
            Polymer.IronResizableBehavior
        ],
        /**
         * Private Properties, used in internal view logic.
         */
        _values: { // attribute values
            INTERACTION: {
                click: 'click',
                focus: 'focus',
                hover: 'hover'
            },
            TYPE: {
                top: 'top',
                bottom: 'bottom',
                left: 'left',
                right: 'right'
            }
        },
        _isShowing: false,
        _mouseInside: false,
        /**
         * Properties block, expose attribute values to the DOM via 'reflect'
         *
         * @property properties
         * @type Object
         */
        properties: {
            /**
             * The id of the element that the tooltip is anchored to. This element
             * must be a sibling of the tooltip.
             */
            for: {
                type: String,
                reflect: true,
                value: 'prev'
            },
            /**
             * The direction that the popover is displayed relative to the
             * 'for' element.
             * - 'auto' calculated at render time or resize
             * - 'left' to the left of the 'for' element
             * - 'right' to the right of the 'for' element
             * - 'top' above the 'for' element
             * - 'bottom' below the 'for' element
             */
            orientation: {
                type: String,
                reflect: true,
                value: 'auto'
            },
            /**
             * The interaction event the invokes the popover
             * - 'click' for ouse click or tap
             * - 'hover' for mouse hover (not recommended for mobile clients)
             * - 'focus' for element focus (for use with form elements)
             */
            interaction: {
                type: String,
                reflect: true,
                value: 'click'
            },
            /**
             * The String to be display in the popover title
             */
            popoverTitle: {
                type: String,
                reflect: true,
                value: 'This is a px-popover'
            },
            /**
             * The String to be display as the popover body
             */
            popoverBody: {
                type: String,
                reflect: true,
                value: 'Capable of displaying a longer body text than a tootip.'
            }
        },
        get target () {
            var ownerRoot = Polymer.dom(this).getOwnerRoot();
            var parentNode = this.parentNode;
            var target;
            if (this.for) {
                target = parentNode.querySelector('#' + this.for);
            } else if (parentNode.nodeType === 11) { // DOCUMENT_FRAGMENT_NODE
                target = ownerRoot.host;
            } else {
                target = parentNode;
            }
            return target;
        },
        listeners: {
            'iron-resize': '_onIronResize'
        },
        attached: function () {
            this._target = this.target;
            this.listen(document, 'click', '_toggle'); // we always listen to click so we can close when clicked outside
            // this.listen(this, 'onscroll', '_onScroll');
            if(this.interaction === this._values.INTERACTION.hover) {
                this.listen(this._target, 'mouseenter', '_toggle');
                this.listen(this._target, 'mouseleave', '_toggle');
            } else if (this.interaction === this._values.INTERACTION.focus) {
                this.listen(this._target, 'focus', '_toggle');
                this.listen(this._target, 'blur', '_toggle');
            }
        },
        detached: function () {
            // hover
            this.unlisten(this._target, 'mouseenter', '_toggle');
            this.unlisten(this._target, 'mouseleave', '_toggle');
            // focus
            this.unlisten(this._target, 'focus', '_toggle');
            this.unlisten(this._target, 'blur', '_toggle');
            // click
            this.unlisten(document, 'click', '_toggle');
        },
        _onIronResize: function () {
            if(this._isShowing) {
                this._setPosition();
            }
        },
        _setMouseInside: function () {
            this._mouseInside = true;
        },
        _isDescendant: function (parent, child) {
        var node = child.parentNode;
            while (node != null) {
                if (node === parent) {
                    return true;
                }
                node = node.parentNode;
            }
            return false;
        },
        _toggle: function (event) {

            // hide the popover if a click is coming from the outside

            if(event.type === this._values.INTERACTION.click) {
                if( this._isDescendant(this, event.target) ) {
                    return false;
                } else {
                    if(event.target.id === this.for) {
                        if(this._isShowing) {
                            this._hide();
                        } else {
                            this._show();
                        }
                        return false;
                    } else { // not our target
                        if(this._isShowing) {
                            this._hide();
                            return false;
                        }
                    }
                }
            }

            if (event.type === 'mouseenter' || event.type === 'mouseleave') {
                if(event.target.id === this.for) {
                    if(this._isShowing) {
                        this._hide();
                    } else {
                        this._show();
                    }
                    return false;
                }
            }
        },
        /**
         * Display the popover
         *
         * @method _show
         */
        _show: function () {
            // show this thing
            this.$.popoverWrapper.classList.remove('hidden');
            this._setPosition();
            this._isShowing = true;
            this.fire('px-popover-show', {
                target: this
            });
        },
        /**
         * Hide the popover
         *
         * @method _hide
         */
        _hide: function () {
            // hide this thing
            this.$.popoverWrapper.classList.add('hidden');
            this._isShowing = false;
        },
        _setPosition: function() {
            if (!this._target) {
              return;
            }

            // using this method so that we can calucate the best position
            // in the _positionXXX methods without having to do recursion.
            this.parentRect = this.offsetParent.getBoundingClientRect();
            this.targetRect = this._target.getBoundingClientRect();
            this.thisRect = this.getBoundingClientRect();
            this.caratRect = this.$.carat.getBoundingClientRect();
            this.margin = parseInt(getComputedStyle(this.$.popover).marginTop.replace('px',''));

            if(this.orientation === this._values.TYPE.left) {
                this._positionLeft();
            } else if (this.orientation === this._values.TYPE.right) {
                this._positionRight();
            } else if (this.orientation === this._values.TYPE.top) {
                this._positionTop();
            } else if (this.orientation === this._values.TYPE.bottom) {
                this._positionBottom();
            } else { // auto
                this._autoPositon();
            }
        },
        _autoPositon: function () {
            this._positionRight();
        },
        _helpers: {
            resetCaratStyle: function () {
                this.$.carat.classList.remove(this._values.TYPE.top,this._values.TYPE.bottom,this._values.TYPE.left,this._values.TYPE.right);
            }
        },
        _positionTop: function () {
            // add the style to the carat
            this.$.carat.classList.add(this._values.TYPE.top);
            this.updateStyles();
            // move the carat to the correct position
            this.caratRect = this.$.carat.getBoundingClientRect();
            this.$.carat.style.left = (this.thisRect.width/2) - (this.caratRect.width/2) + 'px';
            this.$.carat.style.top = (this.thisRect.height - this.margin) + 'px';
            // position the popover itself
            var centerOffset = (this.targetRect.width - this.thisRect.width) / 2;
            this.style.left = (this._target.offsetLeft - (this.thisRect.width/2) + (this.targetRect.width/2)) + 'px';
            this.style.top = (this._target.offsetTop - this.thisRect.height) + this.margin/2 - 5 + 'px';
        },
        _positionBottom: function () {
            // add the style to the carat
            this.$.carat.classList.remove(this._values.TYPE.top,this._values.TYPE.bottom,this._values.TYPE.left,this._values.TYPE.right);
            this.$.carat.classList.add(this._values.TYPE.bottom);
            this.updateStyles();
            // move the carat to the correct position
            this.caratRect = this.$.carat.getBoundingClientRect();
            this.$.carat.style.left = (this.thisRect.width/2) - (this.caratRect.width/2) + 'px';
            // position the popover itself
            var centerOffset = (this.targetRect.width - this.thisRect.width) / 2;
            this.style.left = (this._target.offsetLeft - (this.thisRect.width/2) + (this.targetRect.width/2)) + 'px';
            this.style.top = ((this._target.offsetTop + this.targetRect.height) - this.caratRect.height) + 5 + 'px';
        },
        _positionLeft: function () {
            // add the style to the carat
            this.$.carat.classList.remove(this._values.TYPE.top,this._values.TYPE.bottom,this._values.TYPE.left,this._values.TYPE.right);
            this.$.carat.classList.add(this._values.TYPE.left);
            this.updateStyles();
            // move the carat to the correct position
            this.caratRect = this.$.carat.getBoundingClientRect();
            this.$.carat.style.top = (this.thisRect.height/2) - (this.caratRect.width) + 'px';
            // position the popover itself
            this.style.left = (this._target.offsetLeft - this.thisRect.width) + (this.margin/2) - 5 + 'px';
            this.style.top = Math.round( (this._target.offsetTop + (this.targetRect.height/2)) - (this.thisRect.height/2)) + 'px';
        },
        _positionRight: function () {
            this.$.carat.classList.remove(this._values.TYPE.top,this._values.TYPE.bottom,this._values.TYPE.left,this._values.TYPE.right);

            this.$.carat.classList.add(this._values.TYPE.right);
            this.updateStyles();
            // move the carat to the correct position
            this.caratRect = this.$.carat.getBoundingClientRect();
            this.$.carat.style.top = (this.thisRect.height/2) - (this.caratRect.width) + 'px';
            // position the popover itself
            this.style.left = ((this._target.offsetLeft + this.targetRect.width) - this.caratRect.width) + 5 + 'px';
            this.style.top = Math.round( (this._target.offsetTop + (this.targetRect.height/2)) - (this.thisRect.height/2)) + 'px';
        }

    });
</script>
